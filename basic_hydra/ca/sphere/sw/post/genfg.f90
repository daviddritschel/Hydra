program genfg

! Program for creating an ultra-high resolution image of the PV field
! or a portion thereof from data generated by the hydra/ca/sphere/sw
! suite of f90 codes.

use constants
implicit none

integer,parameter:: mgv=16,ntv=mgv*nt, ngv=mgv*ng
 !mgv:       Ultra-fine conversion grid ratio
 !ntv,ngv:   number of grid boxes in the x & y directions

integer:: n,npt,i,j,iind,loop
integer:: ix,ic,iy,ixx,iyy
integer:: ixf,ix0,ix1,ix2,ix1u,ix2u,ixu
integer:: iyf,iy0,iy1,iy2,iy1u,iy2u,iyu
integer:: nxu,nyu,ixo,iyo,inc,iopt

double precision:: qq0(0:ng,nt),qd(ng,nt)
double precision:: xtd(nt),utd(nt),etd(nt),htd(nt),ptd(nt),xndeno
double precision:: rhs(ngv),etdu(ngv),htdu(ngv)

double precision:: w00(mgv,mgv),w10(mgv,mgv)
double precision:: w01(mgv,mgv),w11(mgv,mgv)
integer:: ixfw(ntv),iyfw(ngv)
integer:: ix0w(ntv),iy0w(ngv)
integer:: ix1w(ntv),iy1w(ngv)

double precision:: xend,fac,pxu,pxc,pyu,pyc
double precision:: t,qsp,qdsp,qdnp,qinc

double precision:: qa(0:ngv+1,ntv+1)
real:: tin,qin(ng,nt),rqa(ngv,ntv),rrqa(ngv/2,ntv/2)
character(len=3):: pind

!---------------------------------------------------------------
 !Initialise area weights for interpolation of residual PV field
 !onto the ultra-fine horizontal grid:
fac=one/dble(mgv)
do ixu=1,mgv
  pxu=fac*dble(ixu-1)
  pxc=one-pxu
  do iyu=1,mgv
    pyu=fac*dble(iyu-1)
    pyc=one-pyu
    w00(iyu,ixu)=pyc*pxc
    w10(iyu,ixu)=pyu*pxc
    w01(iyu,ixu)=pyc*pxu
    w11(iyu,ixu)=pyu*pxu
  enddo
enddo

 !modulo values to access above weights:
do ix=1,ntv
  ixx=(ix-1)/mgv
  ix0w(ix)=1+ixx
  ix1w(ix)=2+ixx-nt*(ix0w(ix)/nt)
  ixfw(ix)=ix-mgv*ixx
enddo

do iy=1,ngv-1
  iyy=iy/mgv
  iy0w(iy)=iyy
  iy1w(iy)=1+iyy
  iyfw(iy)=1+iy-mgv*iyy
enddo

 !Initialise fine-grid 4th-order interpolation (full to half grid):
htdu(1)=one/f74
etdu(1)=-f14*htdu(1)
do j=2,ngv-1
  htdu(j)=one/(f32+f14*etdu(j-1))
  etdu(j)=-f14*htdu(j)
enddo
htdu(ngv)=one/(f74+f14*etdu(ngv-1))

 !Initialise inversion-grid 4th-order interpolation (half to full grid):
htd(1)=one
ptd(1)=-f16*htd(1)
etd(1)=ptd(1)

do j=2,nt
  htd(j)=one/(one+f16*etd(j-1))
  ptd(j)=-f16*ptd(j-1)*htd(j)
  etd(j)=-f16*htd(j)
enddo

ptd(ntm1)=etd(ntm1)+ptd(ntm1)
do j=ntm2,1,-1
  ptd(j)=etd(j)*ptd(j+1)+ptd(j)
enddo

xndeno=one/(one-etd(nt)*ptd(1)-ptd(nt))

!------------------------------------------------------------
write(*,*)
write(*,*) ' Which period do you wish to image (use 0 for initial)?'
read(*,*) iind

write(pind(1:3),'(i3.3)') iind
loop=iind+1

!--------------------------------------------------------------------
 !Read gridded PV field to find the PV value at the south pole (qsp):
open(40,file='evolution/qq.r4',form='unformatted',access='direct', &
                             status='old',recl=nbytes)
read(40,rec=loop) tin,qin
close(40)
 !qin is single precision; convert to double:
do i=1,nt
  do j=1,ng
    qq0(j,i)=dble(qin(j,i))
  enddo
enddo

qsp=zero
 !Form great circles to carry out half grid -> full grid
 !interpolation of qq0:
do ix=1,ng
  ic=ix+ng

   !Source vector:
  utd(1)=f23*(qq0(1,ix)+qq0(1,ic))
  do j=2,ng
    utd(j)=f23*(qq0(j,ix)+qq0(j-1,ix))
  enddo
  utd(ngp1)=f23*(qq0(ng,ic)+qq0(ng,ix))
  do j=ngp2,nt
    utd(j)=f23*(qq0(ntp2-j,ic)+qq0(ntp1-j,ic))
  enddo

   !Interpolate qq0 by 4th-order method (periodic):
  xtd(1)=utd(1)*htd(1)
  do j=2,nt
    xtd(j)=(utd(j)-f16*xtd(j-1))*htd(j)
  enddo
  do j=ntm2,1,-1
    xtd(j)=etd(j)*xtd(j+1)+xtd(j)
  enddo
  xtd(nt)=(etd(nt)*xtd(1)+xtd(nt))*xndeno
  
   !Increment south pole PV value (averaged below):
  qsp=qsp+ptd(1)*xtd(nt)+xtd(1)
enddo

 !Obtain average qsp:
qsp=qsp/dble(ng)

!----------------------------------------------------------------
 !Read residual PV (qd) and convert to full grid as qq0:
open(40,file='contours/qd.r4',form='unformatted',access='direct', &
                            status='old',recl=nbytes)
read(40,rec=loop) tin,qin
qd=dble(qin)
close(40) 

 !Form great circles to carry out half grid -> full grid
 !interpolation of qd:
do ix=1,ng
  ic=ix+ng

   !Source vector:
  utd(1)=f23*(qd(1,ix)+qd(1,ic))
  do j=2,ng
    utd(j)=f23*(qd(j,ix)+qd(j-1,ix))
  enddo
  utd(ngp1)=f23*(qd(ng,ic)+qd(ng,ix))
  do j=ngp2,nt
    utd(j)=f23*(qd(ntp2-j,ic)+qd(ntp1-j,ic))
  enddo

   !Interpolate qd by 4th-order method (periodic):
  xtd(1)=utd(1)*htd(1)
  do j=2,nt
    xtd(j)=(utd(j)-f16*xtd(j-1))*htd(j)
  enddo
  do j=ntm2,1,-1
    xtd(j)=etd(j)*xtd(j+1)+xtd(j)
  enddo
  xtd(nt)=(etd(nt)*xtd(1)+xtd(nt))*xndeno
  xend=xtd(nt)

  do j=1,ntm1
    xtd(j)=ptd(j)*xend+xtd(j)
  enddo

   !Copy back into full grid array (qq0):
  do j=0,ng
    qq0(j,ix)=xtd(j+1)
  enddo
  qq0(0,ic)=xtd(1)
  do j=1,ng
    qq0(j,ic)=xtd(ntp1-j)
  enddo

enddo
 !Ends loops over great circles.  Interpolation complete.

 !Obtain unique polar values of qd for use below:
qdsp=zero
qdnp=zero
do ix=1,nt
  qdsp=qdsp+qq0(0 ,ix)
  qdnp=qdnp+qq0(ng,ix)
enddo
qdsp=qdsp/dble(nt)
qdnp=qdnp/dble(nt)
do ix=1,nt
  qq0(0 ,ix)=qdsp
  qq0(ng,ix)=qdnp
enddo

!----------------------------------------------------------------
!Read PV contours and convert to fine (full) grid as qa:
open(40,file='contours/synopsis.asc',status='old')
do i=1,loop
  read(40,*) t,n,npt
enddo
close(40)

write(*,'(a,f9.1,a)') ' *** Imaging t = ',t

 !Obtain gridded PV (qa) from contours:
call con2ugrid

 !Bi-linear interpolate qq0 to the fine grid and add to qa:
do ix=1,ntv
  ixf=ixfw(ix)
  ix0=ix0w(ix)
  ix1=ix1w(ix)
  
  qa(0,ix)=qa(0,ix)+qdsp
  do iy=1,ngv-1
    iyf=iyfw(iy)
    iy0=iy0w(iy)
    iy1=iy1w(iy)

    qa(iy,ix)=qa(iy,ix)+w00(iyf,ixf)*qq0(iy0,ix0)+w10(iyf,ixf)*qq0(iy1,ix0) &
                     & +w01(iyf,ixf)*qq0(iy0,ix1)+w11(iyf,ixf)*qq0(iy1,ix1)
  enddo
  qa(ngv,ix)=qa(ngv,ix)+qdnp
enddo
 !qdsp & qdnp are the polar qd values (necessarily uniform).

 !Adjustment needed so that the PV at the south pole is the same 
 !as that in pvgrid.dat:
qinc=qsp-qa(0,1)

 !Perform 4th-order compact interpolation to get qa on the half-grid:
do ix=1,ntv
  rhs(1)=qa(1,ix)
  do iy=2,ngv-1
    rhs(iy)=qa(iy,ix)+qa(iy-1,ix)
  enddo
  rhs(ngv)=qa(ngv-1,ix)

  qa(1,ix)=rhs(1)*htdu(1)
  do iy=2,ngv
    qa(iy,ix)=(rhs(iy)-f14*qa(iy-1,ix))*htdu(iy)
  enddo

  do iy=ngv-1,1,-1
    qa(iy,ix)=etdu(iy)*qa(iy+1,ix)+qa(iy,ix)
  enddo
enddo

 !Convert qa+qinc to real*4:
do ix=1,ntv
  do iy=1,ngv
    rqa(iy,ix)=real(qa(iy,ix)+qinc)
  enddo
enddo

 !Open output file:
open(44,file='fine/qq'//pind//'.r4',form='unformatted', &
      access='stream',status='replace')

write(*,*)
write(*,*) ' Choose the type of image:'
write(*,*) '   (1) Full domain view using all data points'
write(*,*) '   (2) As above, but using every nth point'
write(*,*) '   (3) Partial domain view'
read(*,*) iopt

write(*,*) ' Writing fine/qq'//pind//'.r4'
if (iopt .eq. 1) then
  nxu=ntv
  nyu=ngv
  write(44) real(t),rqa
else if (iopt .eq. 2) then
  write(*,*) ' Enter the stride, n:'
  read(*,*) inc
  nxu=ntv/inc
  nyu=ngv/inc
  do ix=1,nxu
    ixo=(ix-1)*inc+1
    do iy=1,nyu
      iyo=(iy-1)*inc+1
      rrqa(iy,ix)=rqa(iyo,ixo)
    enddo
  enddo
  write(44) real(t),rrqa(1:nyu,1:nxu)
else
  write(*,'(a,i5,a)') ' There are ',nt,' longitudes.'
  write(*,*) ' Range of longitude grid points (i1,i2) on original grid?'
  write(*,*) ' (Periodic wrapping is allowed => i2 > i1)'
  read(*,*) ix1,ix2
  ix1u=(ix1-1)*mgv+1
  ix2u=ix2*mgv
   !Allow periodic wrapping:
  nxu=mod(ix2u-ix1u+ntv,ntv)+1
  write(*,'(a,i5,a)') ' There are ',ng,' latitudes.'
  write(*,*) ' Range of latitude grid points (j1,j2) on original grid?'
  read(*,*) iy1,iy2
  iy1u=(iy1-1)*mgv+1
  iy2u=iy2*mgv
  nyu=iy2u-iy1u+1
  if (ix1u .lt. ix2u) then
    write(44) real(t),rqa(iy1u:iy2u,ix1u:ix2u)
  else
    write(44) real(t),rqa(iy1u:iy2u,ix1u:ntv),rqa(iy1u:iy2u,1:ix2u)
  endif
endif

close(44)

write(*,*)
write(*,*) ' Image by typing the command'
write(*,*)
write(*,'(a,i5,1x,i5)') ' dataview fine/qq'//pind//'.r4 -ndim ',nxu,nyu
write(*,*)


!===============================================================

 !Internal subroutine definitions (inherit global variables):

contains 

!=======================================================================

subroutine con2ugrid
! Converts PV contours (x,y,z) to gridded values (qa).

implicit none

 !Local arrays:
double precision:: x(npt),y(npt),z(npt)
double precision:: cx(npt),cy(npt),cz(npt)
double precision:: sq(npt)

double precision:: clonf(ntv),slonf(ntv)
double precision:: dlf,dlfi,rlonf
double precision:: sig,rlatc,p,qasp,qanp

integer:: i1(n),i2(n),np(n),ind(n)
integer:: next(0:npt),ntc(npt),ilm1(npt)
integer:: ibeg,iend,k,ka,i,j,jump,ioff,ncr

!-----------------------------------------------------------------
 !Initialise quantities needed for the contour -> grid conversion:
dlf =twopi/dble(ntv)
dlfi=dble(ntv)/(twopi+small)
do i=1,ntv
  rlonf=dlf*dble(i-1)-pi
  clonf(i)=cos(rlonf)
  slonf(i)=sin(rlonf)
enddo

!-----------------------------------------------------------------
 !Read contour indices and nodes:
open(40,file='contours/index'//pind,form='unformatted',status='old')
read(40) np(1:n),i1(1:n),ind(1:n)
close(40)

open(40,file='contours/nodes'//pind,form='unformatted',status='old')
read(40) x(1:npt),y(1:npt),z(1:npt)
close(40)

 !Construct next array:
do j=1,n
  ibeg=i1(j)
  iend=ibeg+np(j)-1
  do i=ibeg,iend-1
    next(i)=i+1
  enddo
  next(iend)=ibeg
enddo 

!----------------------------------------------------------------
 !Initialise crossing information:
do k=1,npt
  ilm1(k)=int(dlfi*(pi+atan2(y(k),x(k))))
enddo

do k=1,npt
  ka=next(k)
  cx(k)=z(k)*y(ka)-y(k)*z(ka)
  cy(k)=x(k)*z(ka)-z(k)*x(ka)
  cz(k)=x(k)*y(ka)-y(k)*x(ka)
  ntc(k)=ilm1(ka)-ilm1(k)
enddo

do k=1,npt
  sig=sign(one,cz(k))
  sq(k)=dq*sig
  ntc(k)=ntc(k)-ntv*((2*ntc(k))/ntv)
  if (sig*dble(ntc(k)) .lt. zero) ntc(k)=-ntc(k)
  if (abs(cz(k)) .gt. zero) then
    cx(k)=cx(k)/cz(k)
    cy(k)=cy(k)/cz(k)
  endif
enddo

!----------------------------------------------------------------------
 !Initialise PV jump array:
do i=1,ntv
  do j=0,ngv+1
    qa(j,i)=zero
  enddo
enddo

 !Determine crossing indices:
do k=1,npt
  if (ntc(k) .ne. 0) then
    jump=sign(1,ntc(k))
    ioff=ntv+ilm1(k)+(1+jump)/2
    ncr=0
    do while (ncr .ne. ntc(k))
      i=1+mod(ioff+ncr,ntv)
      rlatc=dlfi*(hpi+atan(cx(k)*clonf(i)+cy(k)*slonf(i)))
      j=int(rlatc)+1
      p=rlatc-dble(j-1)
      qa(j,i)=  qa(j,i)+(one-p)*sq(k)
      qa(j+1,i)=qa(j+1,i)+    p*sq(k)
      ncr=ncr+jump
    enddo
  endif
enddo

 !Get PV values, at half latitudes, by sweeping through latitudes:
do i=1,ntv
  do j=2,ngv
    qa(j,i)=qa(j,i)+qa(j-1,i)
  enddo
enddo
 !Here, qa(j,i) stands for the PV at latitude j-1/2,
 !from j = 1, ..., ngv.

 !Determine unique polar values:
qasp=zero
qanp=zero
do i=1,ntv
  qasp=qasp+qa(1  ,i)
  qanp=qanp+qa(ngv,i)
enddo
qasp=qasp/dble(ntv)
qanp=qanp/dble(ntv)

 !Average half-grid PV to full grid:
do i=1,ntv
  qa(0,i)=qasp
  do j=1,ngv-1
    qa(j,i)=f12*(qa(j,i)+qa(j+1,i))
  enddo
  qa(ngv,i)=qanp
enddo

return
end subroutine

!=======================================================================

end program
