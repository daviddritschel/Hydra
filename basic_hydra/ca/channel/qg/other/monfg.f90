program monfg
!  --------------------------------------------------------------------------
!  |   Takes the fine grid PV field generated by genfg.f90 and creates a    |
!  |   monotonic (in y) field (for each x) by sorting.                      |
!  |   Writes fine/monqq<pind>.r4 where <pind> is the selected time period  |
!  --------------------------------------------------------------------------

 !Import constants:
use constants

implicit none

 !Declarations:
integer,parameter:: dbleint=selected_int_kind(16)
integer(kind=dbleint),parameter:: npu=int(nxu,kind=dbleint)*int(nyu+1,kind=dbleint)
double precision,parameter:: glyu=elly/dble(nyu)

real:: tr4, qar4(0:nyu,0:nxum1)
real:: qbot, qtop, qmin, qmax, p, dir, dbin, dbini
real:: y(0:nyu), pdf(nyu), yeq(0:nyu+1), bin(0:nyu+1)

integer:: iind, ix, iy, iz, k
character(len=3):: pind

!-----------------------------------------------------------------
write(*,*) ' What is the numbered suffix of the fine-grid PV file?'
read(*,*) iind
write(pind(1:3),'(i3.3)') iind

 !Open input file:
open(33,file='fine/qq'//pind//'.r4',form='unformatted', &
    & access='direct',status='old',recl=4+npu*4)

 !Open output file:
open(44,file='fine/monqq'//pind//'.r4',form='unformatted', &
    & access='direct',status='replace',recl=4+npu*4)

 !y grid lines (used for making the hovmuller diagrams):
do iy=0,nyu
  y(iy)=ymin+glyu*float(iy)
enddo

 !Process each layer in turn:
do iz=1,nz
   !Read PV field for this layer:
  read(33,rec=iz) tr4,qar4

  qbot=0.
  qtop=0.
  do ix=0,nxum1
    qbot=qbot+qar4(0  ,ix)
    qtop=qtop+qar4(nyu,ix)
  enddo
  qbot=qbot/dble(nxu)
  qtop=qtop/dble(nxu)

   !Sign of PV gradient:
  dir=sign(1.,qtop-qbot)

   !Loop over each column and process:
  do ix=0,nxum1

     !Compute min & max PV:
    qmin=qar4(0,ix)
    qmax=qar4(0,ix)

    do iy=1,nyu
      qmin=min(qmin,qar4(iy,ix))
      qmax=max(qmax,qar4(iy,ix))
    enddo

     !Increment in PV used for binning PV in each column ix = constant:
    dbin=(qmax-qmin)/float(nyu-1)
    dbini=1./dbin

     !Initialise probabilities:
    do k=1,nyu
      pdf(k)=0.
    enddo

     !Edge values at iy = 0 & ny count half:
    k=nint((qar4(0  ,ix)-qmin)*dbini)+1
    pdf(k)=pdf(k)+0.5
    k=nint((qar4(nyu,ix)-qmin)*dbini)+1
    pdf(k)=pdf(k)+0.5

     !Interior values count 1:
    do iy=1,nyu-1
      k=nint((qar4(iy,ix)-qmin)*dbini)+1
      pdf(k)=pdf(k)+1.
    enddo

     !Convert probabilities into equivalent latitudes:
    if (dir .gt. 0.) then
       !Positive mean gradient:
      bin(0)=qmin
      yeq(0)=ymin
      bin(1)=qmin+0.5*dbin
      yeq(1)=pdf(1)*glyu+ymin
      do k=2,nyu
        bin(k)=bin(k-1)+dbin
        yeq(k)=yeq(k-1)+pdf(k)*glyu
      enddo
      bin(nyu+1)=qmax
      yeq(nyu+1)=ymax
       !Invert equivalent latitude to get q_e
      qar4(0,ix)=qmin
      k=0
      do iy=1,nyu-1
        do while (y(iy) .gt. yeq(k+1))
          k=k+1
        enddo
        p=(y(iy)-yeq(k))/(yeq(k+1)-yeq(k))
        qar4(iy,ix)=bin(k)+p*(bin(k+1)-bin(k))
      enddo
      qar4(nyu,ix)=qmax
    else
       !Negative mean gradient:
      bin(0)=qmin
      yeq(0)=ymax
      bin(1)=qmin+0.5*dbin
      yeq(1)=ymax-pdf(1)*glyu
      do k=2,nyu
        bin(k)=bin(k-1)+dbin
        yeq(k)=yeq(k-1)-pdf(k)*glyu
      enddo
      bin(nyu+1)=qmax
      yeq(nyu+1)=ymin
       !Invert equivalent latitude to get q_e
      qar4(0,ix)=qmax
      k=nyu+1
      do iy=1,nyu-1
        do while (y(iy) .gt. yeq(k-1))
          k=k-1
        enddo
        p=(y(iy)-yeq(k))/(yeq(k-1)-yeq(k))
        qar4(iy,ix)=bin(k)+p*(bin(k-1)-bin(k))
      enddo
      qar4(nyu,ix)=qmin
    endif

  enddo
   !Ends loop over columns (ix = constant)

   !Write data for this layer:
  write(44,rec=iz) tr4,qar4
enddo
 !Ends loop over layers

close(33)
close(44)

write(*,*)
write(*,*) '   Image the file using '
write(*,'(a,i5,1x,i5,a)') ' dataview -ndim ',nxu,nyu+1,' fine/monqq'//pind//'.r4'

 !End main program
end program
!=======================================================================
